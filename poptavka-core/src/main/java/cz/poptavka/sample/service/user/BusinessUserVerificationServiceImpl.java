/*
 * Copyright (C) 2007-2011, GoodData(R) Corporation. All rights reserved.
 */
package cz.poptavka.sample.service.user;

import com.googlecode.genericdao.search.Search;
import cz.poptavka.sample.application.security.SymmetricKeyEncryptor;
import cz.poptavka.sample.domain.activation.ActivationEmail;
import cz.poptavka.sample.domain.user.BusinessUser;
import cz.poptavka.sample.domain.user.BusinessUserRole;
import cz.poptavka.sample.domain.user.Verification;
import cz.poptavka.sample.exception.ExpiredActivationLinkException;
import cz.poptavka.sample.exception.IncorrectActivationLinkException;
import cz.poptavka.sample.exception.UserNotExistException;
import cz.poptavka.sample.service.GeneralService;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Date;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.transaction.annotation.Transactional;

public class BusinessUserVerificationServiceImpl implements BusinessUserVerificationService {

    private static final int DEFAULT_VALIDITY_LENGTH_MILLIS = 7 * 24 * 3600 * 1000;

    private final SymmetricKeyEncryptor symmetricEncryptor;
    private final GeneralService generalService;
    private String deploymentUrl;

    private final ObjectMapper jsonMapper = new ObjectMapper();
    private static final String USER_ACTIVATION_RESOURCE_URI = "user/activation?link=";


    public BusinessUserVerificationServiceImpl(SymmetricKeyEncryptor symmetricEncryptor,
            GeneralService generalService) {
        Validate.notNull(symmetricEncryptor);
        Validate.notNull(generalService);

        this.symmetricEncryptor = symmetricEncryptor;
        this.generalService = generalService;
    }

    public void setDeploymentUrl(String deploymentUrl) {
        this.deploymentUrl = deploymentUrl;
    }

    @Override
    public String generateActivationLink(BusinessUser businessUser) {
        Validate.notNull(businessUser, "User to be activated must be specified!");

        final Date now = new Date();
        final Date linkValidTo = new Date(now.getTime() + DEFAULT_VALIDITY_LENGTH_MILLIS);
        final ActivationLink activationLink = new ActivationLink(businessUser.getEmail(), linkValidTo.getTime());

        // URL encoding must be performed because encrypted link can contain '/' character
        final String encryptedLink = encode(symmetricEncryptor.encrypt(serializeLink(activationLink)));

        // emailActivation property can be overwritten multiple times.
        setActivationEmailForUser(businessUser, activationLink, encryptedLink);

        return StringUtils.trimToEmpty(deploymentUrl) + USER_ACTIVATION_RESOURCE_URI
                + businessUser.getActivationEmail().getActivationLink();
    }


    @Override
    @Transactional
    public BusinessUser verifyUser(String activationLink) {
        final BusinessUser businessUser = verifyActivationLink(activationLink);
        for (BusinessUserRole role: businessUser.getBusinessUserRoles()) {
            role.setVerification(Verification.VERIFIED);
        }
        generalService.save(businessUser);
        return businessUser;
    }

    @Override
    @Transactional(readOnly = true)
    public BusinessUser verifyActivationLink(String activationLink) throws UserNotExistException,
            ExpiredActivationLinkException, IncorrectActivationLinkException {
        Validate.notEmpty(activationLink, "Activation link to be verified must not be null!");

        // DO NOT URL DECODE activationLink - this has already be done by Spring MVC infrastructure
        activationLink = stripUrlPrefix(activationLink);
        final ActivationLink decryptedLink = deserializeLink(symmetricEncryptor.decrypt(activationLink));

        if (linkExpired(decryptedLink)) {
            throw new ExpiredActivationLinkException("Activation link expired. "
                    + "New activation link for user must be generated.");
        }

        final BusinessUser userToBeActivated = getUserByEmail(decryptedLink.getUserEmail());
        if (userToBeActivated == null) {
            throw new UserNotExistException("Relevant user does not exist - activation link is broken!");
        }
        if (userToBeActivated.getActivationEmail() == null) {
            throw new IncorrectActivationLinkException("No activation email has been set for user. Activation link "
                    + decryptedLink + " might have been generated by malicious user!");
        }
        // activation link is stored in an encrypted URL encoded form in User table,
        // therefore these forms must be compared!
        if (! activationLink.equals(decode(userToBeActivated.getActivationEmail().getActivationLink()))) {
            throw new IncorrectActivationLinkException("Received activation link is different from the one"
                    + " assigned to the user. Link might have been generated by malicious user!");
        }

        return userToBeActivated;
    }

    //--------------------------------------------------- HELPER METHODS -----------------------------------------------

    private BusinessUser getUserByEmail(String email) {
        Validate.notEmpty(email);

        final Search searchByEmail = new Search(BusinessUser.class);
        searchByEmail.addFilterEqual("email", email.trim());

        // at most one user with given email can exist
        return (BusinessUser) this.generalService.searchUnique(searchByEmail);
    }

    private boolean linkExpired(ActivationLink decryptedLink) {
        final Date now = new Date();
        return now.after(new Date(decryptedLink.getValidity()));
    }

    private String serializeLink(ActivationLink activationLink) {
        try {
            return jsonMapper.writeValueAsString(activationLink);
        } catch (IOException e) {
            throw new IllegalStateException("Activation link cannot be serialized!");
        }
    }

    private ActivationLink deserializeLink(String activationLink) {
        try {
            return jsonMapper.readValue(activationLink, ActivationLink.class);
        } catch (IOException e) {
            throw new IllegalStateException("Activation link cannot be deserialized!", e);
        }
    }

    private String stripUrlPrefix(String activationLinkPlainText) {
        Validate.notEmpty(activationLinkPlainText);
        if (activationLinkPlainText.startsWith(deploymentUrl)) {
            activationLinkPlainText = activationLinkPlainText.substring(deploymentUrl.length());
        }
        if (activationLinkPlainText.startsWith(USER_ACTIVATION_RESOURCE_URI)) {
            activationLinkPlainText = activationLinkPlainText.substring(USER_ACTIVATION_RESOURCE_URI.length());
        }

        return activationLinkPlainText;
    }

    private void setActivationEmailForUser(BusinessUser user, ActivationLink activationLink, String linkString) {
        final ActivationEmail activationEmail = new ActivationEmail();
        activationEmail.setActivationLink(linkString);
        activationEmail.setValidTo(new Date(activationLink.getValidity()));
        user.setActivationEmail(activationEmail);
    }

    private String encode(String paramValue) {
        try {
            return URLEncoder.encode(paramValue, "utf-8");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("Never should occur - unsupported encoding", e);
        }
    }

    private String decode(String urlEncoded) {
        try {
            return URLDecoder.decode(urlEncoded, "utf-8");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("Never should occur - unsupported encoding", e);
        }
    }

    /**
     * Nested class for more handy work with activation links.
     */
    private static class ActivationLink {

        private String userEmail;
        private long validity;

        private ActivationLink() {
            // ONLY FOR JACKSON deserialization mechanism
        }

        public ActivationLink(String userEmail, long validity) {
            this.userEmail = userEmail;
            this.validity = validity;
        }


        public long getValidity() {
            return validity;
        }

        public void setValidity(long validity) {
            this.validity = validity;
        }

        public String getUserEmail() {
            return userEmail;
        }

        public void setUserEmail(String userEmail) {
            this.userEmail = userEmail;
        }

    }

}
